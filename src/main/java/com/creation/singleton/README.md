#单例模式（Singleton Pattern）：
    确保某一个类只有一个实例，且自行实例化，并向整个系统提供这个实例。单例模式是一种对象创建型模式
    保证一个类仅有一个实例，并提供一个访问它的全局访问点。
    
#单例模式特点： 
    1.单例模式限制了类的实例化,单例类只能有一个实例。
    2.单例类必须自己创建自己的唯一实例。
    3.单例类必须给所有其他对象提供这一实例。
    4.避免对共享资源的多重占用
#单例模式特点： 
    1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。
    2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
    3.单例类的职责过重，在一定程度上违背了“单一职责原则”
#单例实现方式：
######为了实现Singleton模式，我们有不同的方法，但是所有方法都具有以下共同概念。
    1.私有构造函数，用于限制该类从其他类的实例化。
    2.同一类的私有静态变量，是该类的唯一实例。
    3.返回类实例的公共静态方法，这是外部世界获取单例类实例的全局访问点。
#饿汉式：单例实例在类加载时就构建，急切初始化。
##优点 
    1.简单。创建单例模式最简单的一种方式。
    2.线程安全。
    3.速度快。由于类加载时已经进行初始化，调用速度快。
##缺点 
    1.浪费资源。没有调用对象，也会创建。
    2.没有异常处理。 
#懒汉式：实现单例模式的惰性初始化方法在全局访问方法中创建实例
##优点： 
    在单线程中可以实现按需加载。 
##缺点： 
    不适用于多线程。 多线程时，可能存在破环单例模式情况。
    懒汉式在单个线程中没问题，但多个线程同时访问的时候就可能同时创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。
#双重校验：
    第一次校验：由于单例模式只需要创建一次实例，如果后面再次调用getInstance方法时，则直接返回之前创建的实例，因此大部分时间不需要执行同步方法里面的代码，大大提高了性能。如果不加第一次校验的话，那跟上面的懒汉模式没什么区别，每次都要去竞争锁。
    第二次校验：如果没有第二次校验，假设线程t1执行了第一次校验后，判断为null，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为null。接下来t2获得锁，创建实例。这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为null（不会再次判断），获得锁后，直接创建实例。结果就会导致创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。
###补充:
    关于锁内部的第二重空判断的作用，当多个线程一起到达锁位置时，进行锁竞争，其中一个线程获取锁，如果是第一次进入则doubleCheckSingleton为null，会进行单例对象的创建，完成后释放锁，其他线程获取锁后就会被空判断拦截，直接返回已创建的单例对象
#枚举：通过枚举实现单例的方式是可以避免反射攻击,建议使用枚举单例
##优点：
    1.创建枚举默认就是线程安全的。
    2.防止反序列化导致重新创建新的对象。保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）。
    3.effective java 中推荐。
##缺点：
    灵活性不足
#其他：
    使用volatile的目的是为了防止暴露一个未初始化的不完整单例实例，导致系统崩溃。因为创建单例实例其实需要经过以下几步：首先分配内存空间、然后将内存空间的首地址指向引用（指针），最后调用构造器创建实例，由于在第二步的时候这个引用（指针）就会变的非null，那么在第三步未执行，真正的单例实例还未创建完成的时候，一个线程过来在第一个校验中为false，将会直接将不完整的实例返回，从而造成系统崩溃。
###私有化构造器并不保险
    《effective java》中只简单的提了几句话：“享有特权的客户端可以借助AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。如果需要低于这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。
###序列化问题
      任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。”当然，这个问题也是可以解决的，想详细了解的同学可以翻看《effective java》第77条：对于实例控制，枚举类型优于readResolve
#区别：
    建议使用枚举单例：通过枚举实现单例的方式是可以避免反射攻击
    双重校验与饿汉模式不同的是，它是在内部类里面去创建对象实例。这样就能实现我们的双重目的：延迟加载和线程安全。